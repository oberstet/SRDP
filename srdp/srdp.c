//////////////////////////////////////////////////////////////////////////////#
//
//  Copyright 2013 Tavendo GmbH
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//
//////////////////////////////////////////////////////////////////////////////#

#include "srdp.h"

#ifdef __cplusplus
extern "C" {
#endif

#ifdef SRDP_DUMMY

void srdp_init_channel(srdp_channel_t* channel,
                       srdp_transport_write transport_write,
                       srdp_transport_read transport_read,
                       srdp_register_write register_write,
                       srdp_register_read register_read,
                       void* userdata) {
}

int srdp_register_change(srdp_channel_t* channel,
                         int dev,
                         int reg,
                         int pos,
                         int len,
                         const uint8_t* data) {
   return 0;
}

void srdp_loop(srdp_channel_t* channel) {
}

#else // SRDP_DUMMY

/*
 * Code generated by universal_crc by Danjel McGougan
 * http://www.mcgougan.se/universal_crc/
 *
 * CRC parameters used:
 *   bits:       16
 *   poly:       0x1021
 *   init:       0x0000
 *   xor:        0x0000
 *   reverse:    false
 *   non-direct: false
 *
 * CRC of the string "123456789" is 0x31c3
 */

#include <stddef.h>
#include <stdint.h>


#ifdef SRDP_CRC16_BIG_AND_FAST

static const uint16_t crc_table[256] = {
   0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50a5, 0x60c6, 0x70e7,
   0x8108, 0x9129, 0xa14a, 0xb16b, 0xc18c, 0xd1ad, 0xe1ce, 0xf1ef,
   0x1231, 0x0210, 0x3273, 0x2252, 0x52b5, 0x4294, 0x72f7, 0x62d6,
   0x9339, 0x8318, 0xb37b, 0xa35a, 0xd3bd, 0xc39c, 0xf3ff, 0xe3de,
   0x2462, 0x3443, 0x0420, 0x1401, 0x64e6, 0x74c7, 0x44a4, 0x5485,
   0xa56a, 0xb54b, 0x8528, 0x9509, 0xe5ee, 0xf5cf, 0xc5ac, 0xd58d,
   0x3653, 0x2672, 0x1611, 0x0630, 0x76d7, 0x66f6, 0x5695, 0x46b4,
   0xb75b, 0xa77a, 0x9719, 0x8738, 0xf7df, 0xe7fe, 0xd79d, 0xc7bc,
   0x48c4, 0x58e5, 0x6886, 0x78a7, 0x0840, 0x1861, 0x2802, 0x3823,
   0xc9cc, 0xd9ed, 0xe98e, 0xf9af, 0x8948, 0x9969, 0xa90a, 0xb92b,
   0x5af5, 0x4ad4, 0x7ab7, 0x6a96, 0x1a71, 0x0a50, 0x3a33, 0x2a12,
   0xdbfd, 0xcbdc, 0xfbbf, 0xeb9e, 0x9b79, 0x8b58, 0xbb3b, 0xab1a,
   0x6ca6, 0x7c87, 0x4ce4, 0x5cc5, 0x2c22, 0x3c03, 0x0c60, 0x1c41,
   0xedae, 0xfd8f, 0xcdec, 0xddcd, 0xad2a, 0xbd0b, 0x8d68, 0x9d49,
   0x7e97, 0x6eb6, 0x5ed5, 0x4ef4, 0x3e13, 0x2e32, 0x1e51, 0x0e70,
   0xff9f, 0xefbe, 0xdfdd, 0xcffc, 0xbf1b, 0xaf3a, 0x9f59, 0x8f78,
   0x9188, 0x81a9, 0xb1ca, 0xa1eb, 0xd10c, 0xc12d, 0xf14e, 0xe16f,
   0x1080, 0x00a1, 0x30c2, 0x20e3, 0x5004, 0x4025, 0x7046, 0x6067,
   0x83b9, 0x9398, 0xa3fb, 0xb3da, 0xc33d, 0xd31c, 0xe37f, 0xf35e,
   0x02b1, 0x1290, 0x22f3, 0x32d2, 0x4235, 0x5214, 0x6277, 0x7256,
   0xb5ea, 0xa5cb, 0x95a8, 0x8589, 0xf56e, 0xe54f, 0xd52c, 0xc50d,
   0x34e2, 0x24c3, 0x14a0, 0x0481, 0x7466, 0x6447, 0x5424, 0x4405,
   0xa7db, 0xb7fa, 0x8799, 0x97b8, 0xe75f, 0xf77e, 0xc71d, 0xd73c,
   0x26d3, 0x36f2, 0x0691, 0x16b0, 0x6657, 0x7676, 0x4615, 0x5634,
   0xd94c, 0xc96d, 0xf90e, 0xe92f, 0x99c8, 0x89e9, 0xb98a, 0xa9ab,
   0x5844, 0x4865, 0x7806, 0x6827, 0x18c0, 0x08e1, 0x3882, 0x28a3,
   0xcb7d, 0xdb5c, 0xeb3f, 0xfb1e, 0x8bf9, 0x9bd8, 0xabbb, 0xbb9a,
   0x4a75, 0x5a54, 0x6a37, 0x7a16, 0x0af1, 0x1ad0, 0x2ab3, 0x3a92,
   0xfd2e, 0xed0f, 0xdd6c, 0xcd4d, 0xbdaa, 0xad8b, 0x9de8, 0x8dc9,
   0x7c26, 0x6c07, 0x5c64, 0x4c45, 0x3ca2, 0x2c83, 0x1ce0, 0x0cc1,
   0xef1f, 0xff3e, 0xcf5d, 0xdf7c, 0xaf9b, 0xbfba, 0x8fd9, 0x9ff8,
   0x6e17, 0x7e36, 0x4e55, 0x5e74, 0x2e93, 0x3eb2, 0x0ed1, 0x1ef0
};

uint16_t crc_calc (const uint8_t *data, size_t len)
{
   uint16_t crc = 0;

   if (len) do {
      crc = (crc << 8) ^ crc_table[((crc >> 8) & 0xff) ^ *data++];
   } while (--len);

   return crc;
}

#else // SRDP_CRC16_BIG_AND_FAST

static const uint16_t crc_table[16] = {
   0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50a5, 0x60c6, 0x70e7,
   0x8108, 0x9129, 0xa14a, 0xb16b, 0xc18c, 0xd1ad, 0xe1ce, 0xf1ef
};

uint16_t crc_calc(const uint8_t *data, size_t len)
{
   uint16_t crc = 0;

   if (len) do {
      crc ^= (uint16_t) *data++ << 8;
      crc = (crc << 4) ^ crc_table[(crc >> 12) & 15];
      crc = (crc << 4) ^ crc_table[(crc >> 12) & 15];
   } while (--len);

   return crc;
}

#endif // SRDP_CRC16_BIG_AND_FAST



void send_frame(srdp_channel_t* channel, int ft, int op, int dev, int reg, size_t pos, size_t len) {

   // | FT (2) | OP (2) | DEV (12) |
   //
   channel->out.header.fields.opdev = ((ft & 0x03) << 14) | ((op & 0x03) << 12) | (dev & 0x0fff);

   // frame sequence number
   //
   if (op == SRDP_OP_CHANGE) {
      // for adapter initiated frames, we have an outgoing
      // frame sequence number
      channel->_seq_out += 1;
      channel->out.header.fields.seq = channel->_seq_out;
   } else {
      // for host initiated frames, we echo back the frame
      // sequence number of the frame received from the host
      channel->out.header.fields.seq = channel->_seq_in;
   }

   // other frame header fields
   //
   channel->out.header.fields.reg = reg;
   channel->out.header.fields.pos = pos;
   channel->out.header.fields.len = len;

   // Compute CRC: the CRC is CRC-16 (like Xmodem .. see above for parameters) computed
   // over _all_ frame header fields (with CRC16 field set to 0) and all of the frame data.
   // Only _after_ computation the frame header field is set to the actually computed value.
   //
   channel->out.header.fields.crc16 = 0;
   uint16_t crc = crc_calc(channel->out.header.buffer, SRDP_FRAME_HEADER_LEN + len);
   channel->out.header.fields.crc16 = crc;

   // now transmit frame header and data in one (!) go. this needs to be 1 call to the
   // user supplied callback since that callback could map to sending 1 UDP datagram.
   // and we don't want to split up a SRDP frame between different transport datagrams.
   //
   int total = SRDP_FRAME_HEADER_LEN + len;
   channel->transport_write(channel->userdata, channel->out.header.buffer, total);
   channel->_sent_octets += total;
   channel->_sent_frames += 1;
}


// Read handler for driver builtin registers
//
int driver_register_read (void* userdata, int dev, int reg, int pos, int len, uint8_t* data) {

   srdp_channel_t* channel = (srdp_channel_t*) userdata;

   if (dev == 0) {
      int l;

      switch (reg) {

         // Stats: Register Changes
         //
         case 4:
            if (pos == 0 && (len == 12 || len == 0)) {
               *((uint32_t*) (data + 0)) = channel->_sent_reg_change_req;
               *((uint32_t*) (data + 4)) = channel->_recv_reg_change_ack;
               *((uint32_t*) (data + 8)) = channel->_recv_reg_change_err;
               return 12;
            } else {
               return SRDP_ERR_INVALID_REG_POSLEN;
            }

         // Stats: QQLL - Octets Received, Octets Sent, Frames Received, Frames Sent
         //
         case 5:
            if (pos == 0 && (len == 24 || len == 0)) {
               *((uint64_t*) (data + 0)) = channel->_recv_octets;
               *((uint64_t*) (data + 8)) = channel->_sent_octets;
               *((uint32_t*) (data + 16)) = channel->_recv_frames;
               *((uint32_t*) (data + 20)) = channel->_sent_frames;
               return 24;
            } else {
               return SRDP_ERR_INVALID_REG_POSLEN;
            }

         default:
            return SRDP_ERR_NO_SUCH_REGISTER;
      }
   } else {
      return SRDP_ERR_NO_SUCH_DEVICE;
   }
}


void process_incoming_frame (srdp_channel_t* channel) {

   int ft = (channel->in.header.fields.opdev >> 14) & 0x3;
   int op = (channel->in.header.fields.opdev >> 12) & 0x3;
   int dev = channel->in.header.fields.opdev & 0x0fff;
   int reg = channel->in.header.fields.reg;
   int pos = channel->in.header.fields.pos;
   int len = channel->in.header.fields.len;

   int res = SRDP_ERR_NOT_IMPLEMENTED;

   switch (ft) {
      case SRDP_FT_REQ:
         switch (op) {            

            // register read
            //
            case SRDP_OP_READ:
               if (dev == 0 && reg < 1024) {
                  // driver builtin register
                  res = driver_register_read(channel, dev, reg, pos, len, channel->out.data);
               }
               else if (channel->register_read) {
                  res = channel->register_read(channel->userdata, dev, reg, pos, len, channel->out.data);
               } else {
                  // FIXME: send error
               }

               if (res < 0) {
                  // FIXME: send error
               } else {
                  send_frame(channel, SRDP_FT_ACK, SRDP_OP_READ, dev, reg, pos, res);
               }
               break;

            // register write
            //
            case SRDP_OP_WRITE:
               if (channel->register_write) {
                  res = channel->register_write(channel->userdata, dev, reg, pos, len, channel->in.data);
                  if (res < 0) {
                     // FIXME: send error
                  } else {
                     channel->out.data[0] = 7;
                     send_frame(channel, SRDP_FT_ACK, SRDP_OP_WRITE, dev, reg, pos, res);
                  }
               } else {
                  // FIXME: send error
               }
               break;

            // unknown operation
            //
            default:
               // FIXME: send error
               break;
         }
         break;

      case SRDP_FT_ACK:
         if (op == SRDP_OP_CHANGE) {
            channel->_recv_reg_change_ack += 1;
         } else {
            // FIXME: error
         }         
         break;

      case SRDP_FT_ERR:
         if (op == SRDP_OP_CHANGE) {
            channel->_recv_reg_change_err += 1;
         } else {
            // FIXME: error
         }         
         break;

      default:
         break;
   }
}

void srdp_init_channel(srdp_channel_t* channel,
                       srdp_transport_write transport_write,
                       srdp_transport_read transport_read,
                       srdp_register_write register_write,
                       srdp_register_read register_read,
                       void* userdata) {

   channel->transport_read = transport_read;
   channel->transport_write = transport_write;

   channel->register_read = register_read;
   channel->register_write = register_write;

   channel->userdata = userdata;

   channel->_seq_in = 0;
   channel->_seq_out = 0;

   channel->_bytes_received = 0;

   channel->_sent_reg_change_req = 0;
   channel->_recv_reg_change_ack = 0;
   channel->_recv_reg_change_err = 0;

   channel->_recv_octets = 0;
   channel->_sent_octets = 0;
   channel->_recv_frames = 0;
   channel->_sent_frames = 0;
}


int srdp_register_change(srdp_channel_t* channel, int dev, int reg, int pos, int len, const uint8_t* data) {
   if (true) {
      int i;
      for (i = 0; i < len; ++i) {
         channel->out.data[i] = data[i];
      }
      send_frame(channel, SRDP_FT_REQ, SRDP_OP_CHANGE, dev, reg, pos, len);
      channel->_sent_reg_change_req += 1;
   }
}


void srdp_loop(srdp_channel_t* channel) {

   uint8_t* rptr = channel->in.header.buffer + channel->_bytes_received;
   int got = channel->transport_read(channel->userdata, rptr, SRDP_FRAME_HEADER_LEN + SRDP_FRAME_DATA_MAX_LEN - channel->_bytes_received);
   int rest = 0;

   if (got > 0) {
      channel->_bytes_received += got;
      channel->_recv_octets += got;

      do {

         // we need at least the frame header to determine frame data length ..
         //
         if (channel->_bytes_received >= SRDP_FRAME_HEADER_LEN) {

            int total_frame_len = SRDP_FRAME_HEADER_LEN + channel->in.header.fields.len;

            // now that we know frame data length, we want at least the complete frame ..
            //
            if (channel->_bytes_received >= total_frame_len) {

               // complete frame received
               //
               channel->_recv_frames += 1;
               process_incoming_frame(channel);

               // if there is a rest left (octets for a subsequent frame), move that
               // to front of frame buffer
               //
               rest = channel->_bytes_received - total_frame_len;
               if (rest > 0) {
                  uint8_t* src = channel->in.header.buffer + total_frame_len;
                  uint8_t* dest = channel->in.header.buffer;
                  int i;
                  for (i = 0; i < rest; ++i) {
                     dest[i] = src[i];
                  }
               }
               channel->_bytes_received = rest;

            } else {
               // need more frame data octets ..
            }
         } else {
            // need more frame header octets ..
         }

      } while (rest > 0); // consume everything received
   }
}

#endif // SRDP_DUMMY

#ifdef __cplusplus
}
#endif
